// Code generated by polyglot-rs v0.1.0, DO NOT EDIT.
// source: examples/tests/tests.proto

use num_enum::TryFromPrimitive;
use polyglot::{Decoder, DecodingError, Encoder, Kind};
use std::collections::HashMap;
use std::convert::TryFrom;
use std::io::Cursor;

#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]
#[repr(u32)]
pub enum Test {
    Potato = 0,
    Monkey = 1,
}

pub trait Encode {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>>;
}

pub trait Decode {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Self>, DecodingError>
    where
        Self: Sized;
}

#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]
#[repr(u32)]
pub enum RequestCorpus {
    Universal = 0,
    Web = 1,
    Images = 2,
    Local = 3,
    News = 4,
    Products = 5,
    Video = 6,
}

struct Request {
    message: String,
    corpus: RequestCorpus,
}

impl Encode for Request {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_string(&*self.message)
            .encode_u32(self.corpus as u32);
        b
    }
}

impl Decode for Request {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Request>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(Request {
            message: b.decode_string()?,
            corpus: RequestCorpus::try_from(b.decode_u32()?)
                .ok()
                .ok_or(DecodingError::InvalidEnum)?,
        }))
    }
}

struct Response {
    message: String,
    test: Data,
}

impl Encode for Response {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_string(&*self.message);

        self.test.encode(b);
        b
    }
}

impl Decode for Response {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Response>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(Response {
            test: Data::decode(b)?.ok_or(DecodingError::InvalidStruct)?,
            message: b.decode_string()?,
        }))
    }
}

struct Data {
    message: String,
    checker: Test,
}

impl Encode for Data {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_string(&*self.message)
            .encode_u32(self.checker as u32);
        b
    }
}

impl Decode for Data {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Data>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(Data {
            message: b.decode_string()?,
            checker: Test::try_from(b.decode_u32()?)
                .ok()
                .ok_or(DecodingError::InvalidEnum)?,
        }))
    }
}

#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]
#[repr(u32)]
pub enum MyMessage1EnumAllowingAlias {
    UNKNOWN = 0,
    STARTED = 1,
    RUNNING = 2,
}

struct MyMessage1 {}

impl Encode for MyMessage1 {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b
    }
}

impl Decode for MyMessage1 {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<MyMessage1>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(MyMessage1 {}))
    }
}

#[derive(Debug, Eq, PartialEq, TryFromPrimitive)]
#[repr(u32)]
pub enum MyMessage2EnumNotAllowingAlias {
    UNKNOWN = 0,
    STARTED = 1,
}

struct MyMessage2 {}

impl Encode for MyMessage2 {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b
    }
}

impl Decode for MyMessage2 {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<MyMessage2>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(MyMessage2 {}))
    }
}

struct SearchResponseResult {
    url: String,
    title: String,
    snippets: Vec<String>,
}

impl Encode for SearchResponseResult {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_string(&*self.url).encode_string(&*self.title);

        b.encode_array(self.snippets.len(), Kind::String);
        for item in self.snippets {
            b.encode_string(&*item);
        }
        b
    }
}

impl Decode for SearchResponseResult {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<SearchResponseResult>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        let snippets_size = b.decode_array(Kind::String)?;
        let mut snippets_temp = Vec::with_capacity(snippets_size);
        for _ in 0..snippets_size {
            snippets_temp.push(b.decode_string()?);
        }
        Ok(Some(SearchResponseResult {
            snippets: snippets_temp,
            url: b.decode_string()?,
            title: b.decode_string()?,
        }))
    }
}

struct SearchResponse {
    results: Vec<SearchResponseResult>,
    results2: Vec<SearchResponseResult>,
    snippets: Vec<String>,
    snippets2: Vec<String>,
}

impl Encode for SearchResponse {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_array(self.results.len(), Kind::Any);
        for item in self.results {
            item.encode(b);
        }
        b.encode_array(self.results2.len(), Kind::Any);
        for item in self.results2 {
            item.encode(b);
        }
        b.encode_array(self.snippets.len(), Kind::String);
        for item in self.snippets {
            b.encode_string(&*item);
        }
        b.encode_array(self.snippets2.len(), Kind::String);
        for item in self.snippets2 {
            b.encode_string(&*item);
        }
        b
    }
}

impl Decode for SearchResponse {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<SearchResponse>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        let results_size = b.decode_array(Kind::Any)?;
        let mut results_temp = Vec::with_capacity(results_size);
        for _ in 0..results_size {
            results_temp.push(SearchResponseResult::decode(b)?.ok_or(DecodingError::InvalidArray)?);
        }
        let results2_size = b.decode_array(Kind::Any)?;
        let mut results2_temp = Vec::with_capacity(results2_size);
        for _ in 0..results2_size {
            results2_temp
                .push(SearchResponseResult::decode(b)?.ok_or(DecodingError::InvalidArray)?);
        }
        let snippets_size = b.decode_array(Kind::String)?;
        let mut snippets_temp = Vec::with_capacity(snippets_size);
        for _ in 0..snippets_size {
            snippets_temp.push(b.decode_string()?);
        }
        let snippets2_size = b.decode_array(Kind::String)?;
        let mut snippets2_temp = Vec::with_capacity(snippets2_size);
        for _ in 0..snippets2_size {
            snippets2_temp.push(b.decode_string()?);
        }
        Ok(Some(SearchResponse {
            results: results_temp,
            results2: results2_temp,
            snippets: snippets_temp,
            snippets2: snippets2_temp,
        }))
    }
}

struct Resulting {
    url: String,
    title: String,
    snippets: Vec<String>,
}

impl Encode for Resulting {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_string(&*self.url).encode_string(&*self.title);

        b.encode_array(self.snippets.len(), Kind::String);
        for item in self.snippets {
            b.encode_string(&*item);
        }
        b
    }
}

impl Decode for Resulting {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Resulting>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        let snippets_size = b.decode_array(Kind::String)?;
        let mut snippets_temp = Vec::with_capacity(snippets_size);
        for _ in 0..snippets_size {
            snippets_temp.push(b.decode_string()?);
        }
        Ok(Some(Resulting {
            snippets: snippets_temp,
            url: b.decode_string()?,
            title: b.decode_string()?,
        }))
    }
}

struct SomeOtherMessage {
    result: SearchResponseResult,
}

impl Encode for SomeOtherMessage {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        self.result.encode(b);
        b
    }
}

impl Decode for SomeOtherMessage {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<SomeOtherMessage>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(SomeOtherMessage {
            result: SearchResponseResult::decode(b)?.ok_or(DecodingError::InvalidStruct)?,
        }))
    }
}

struct OuterMiddleAAInner {
    ival: i64,
    booly: bool,
}

impl Encode for OuterMiddleAAInner {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_i64(self.ival).encode_bool(self.booly);
        b
    }
}

impl Decode for OuterMiddleAAInner {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<OuterMiddleAAInner>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(OuterMiddleAAInner {
            ival: b.decode_i64()?,
            booly: b.decode_bool()?,
        }))
    }
}

struct OuterMiddleAA {
    inner: OuterMiddleAAInner,
}

impl Encode for OuterMiddleAA {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        self.inner.encode(b);
        b
    }
}

impl Decode for OuterMiddleAA {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<OuterMiddleAA>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(OuterMiddleAA {
            inner: OuterMiddleAAInner::decode(b)?.ok_or(DecodingError::InvalidStruct)?,
        }))
    }
}

struct OuterMiddleBBInner {
    ival: i32,
    booly: bool,
}

impl Encode for OuterMiddleBBInner {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_i32(self.ival).encode_bool(self.booly);
        b
    }
}

impl Decode for OuterMiddleBBInner {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<OuterMiddleBBInner>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(OuterMiddleBBInner {
            ival: b.decode_i32()?,
            booly: b.decode_bool()?,
        }))
    }
}

struct OuterMiddleBB {
    inner: OuterMiddleBBInner,
}

impl Encode for OuterMiddleBB {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        self.inner.encode(b);
        b
    }
}

impl Decode for OuterMiddleBB {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<OuterMiddleBB>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(OuterMiddleBB {
            inner: OuterMiddleBBInner::decode(b)?.ok_or(DecodingError::InvalidStruct)?,
        }))
    }
}

struct Outer {
    a: OuterMiddleAA,
    b: OuterMiddleBB,
}

impl Encode for Outer {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        self.a.encode(b);
        self.b.encode(b);
        b
    }
}

impl Decode for Outer {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<Outer>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(Outer {
            a: OuterMiddleAA::decode(b)?.ok_or(DecodingError::InvalidStruct)?,
            b: OuterMiddleBB::decode(b)?.ok_or(DecodingError::InvalidStruct)?,
        }))
    }
}

struct SampleMessage {
    name: String,
    potato: String,
}

impl Encode for SampleMessage {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_string(&*self.name).encode_string(&*self.potato);
        b
    }
}

impl Decode for SampleMessage {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<SampleMessage>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        Ok(Some(SampleMessage {
            name: b.decode_string()?,
            potato: b.decode_string()?,
        }))
    }
}

struct TestPotato {
    prices: HashMap<String, Test>,
}

impl Encode for TestPotato {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_map(self.prices.len(), Kind::String, Kind::U32);
        for (k, v) in self.prices {
            b.encode_string(&*k);
            b.encode_u32(v as u32);
        }
        b
    }
}

impl Decode for TestPotato {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<TestPotato>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        fn prices_decode(
            b: &mut Cursor<&mut Vec<u8>>,
        ) -> Result<Option<HashMap<String, Test>>, DecodingError> {
            if b.decode_none() {
                return Ok(None);
            }

            let size = b
                .decode_map(Kind::String, Kind::U32)
                .ok()
                .ok_or(DecodingError::InvalidU32)?;
            let mut map = HashMap::new();
            for _ in 0..size {
                let k = b.decode_string()?;
                let v = Test::try_from(b.decode_u32()?)
                    .ok()
                    .ok_or(DecodingError::InvalidMap)?;
                map.insert(k, v);
            }
            Ok(Some(map))
        }
        Ok(Some(TestPotato {
            prices: prices_decode(b)?.ok_or(DecodingError::InvalidMap)?,
        }))
    }
}

struct StockPrices {
    prices: HashMap<String, f64>,
}

impl Encode for StockPrices {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_map(self.prices.len(), Kind::String, Kind::F64);
        for (k, v) in self.prices {
            b.encode_string(&*k);
            b.encode_f64(v);
        }
        b
    }
}

impl Decode for StockPrices {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<StockPrices>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        fn prices_decode(
            b: &mut Cursor<&mut Vec<u8>>,
        ) -> Result<Option<HashMap<String, f64>>, DecodingError> {
            if b.decode_none() {
                return Ok(None);
            }

            let size = b
                .decode_map(Kind::String, Kind::F64)
                .ok()
                .ok_or(DecodingError::InvalidU32)?;
            let mut map = HashMap::new();
            for _ in 0..size {
                let k = b.decode_string()?;
                let v = b.decode_f64()?;
                map.insert(k, v);
            }
            Ok(Some(map))
        }
        Ok(Some(StockPrices {
            prices: prices_decode(b)?.ok_or(DecodingError::InvalidMap)?,
        }))
    }
}

struct StockPricesWrapper {
    sprices: Vec<StockPrices>,
}

impl Encode for StockPricesWrapper {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_array(self.sprices.len(), Kind::Any);
        for item in self.sprices {
            item.encode(b);
        }
        b
    }
}

impl Decode for StockPricesWrapper {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<StockPricesWrapper>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        let sprices_size = b.decode_array(Kind::Any)?;
        let mut sprices_temp = Vec::with_capacity(sprices_size);
        for _ in 0..sprices_size {
            sprices_temp.push(StockPrices::decode(b)?.ok_or(DecodingError::InvalidArray)?);
        }
        Ok(Some(StockPricesWrapper {
            sprices: sprices_temp,
        }))
    }
}

struct StockPricesSuperWrap {
    prices: HashMap<String, StockPricesWrapper>,
}

impl Encode for StockPricesSuperWrap {
    fn encode(self, b: &mut Cursor<Vec<u8>>) -> &mut Cursor<Vec<u8>> {
        b.encode_map(self.prices.len(), Kind::String, Kind::Any);
        for (k, v) in self.prices {
            b.encode_string(&*k);
            v.encode(b);
        }
        b
    }
}

impl Decode for StockPricesSuperWrap {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Option<StockPricesSuperWrap>, DecodingError> {
        if b.decode_none() {
            return Ok(None);
        }

        fn prices_decode(
            b: &mut Cursor<&mut Vec<u8>>,
        ) -> Result<Option<HashMap<String, StockPricesWrapper>>, DecodingError> {
            if b.decode_none() {
                return Ok(None);
            }

            let size = b
                .decode_map(Kind::String, Kind::Any)
                .ok()
                .ok_or(DecodingError::InvalidU32)?;
            let mut map = HashMap::new();
            for _ in 0..size {
                let k = b.decode_string()?;
                let v = StockPricesWrapper::decode(b)?.ok_or(DecodingError::InvalidMap)?;
                map.insert(k, v);
            }
            Ok(Some(map))
        }
        Ok(Some(StockPricesSuperWrap {
            prices: prices_decode(b)?.ok_or(DecodingError::InvalidMap)?,
        }))
    }
}
